# 河南萌新联赛第二场

## B-异或期望的秘密（数学，位运算）

涉及到挺多东西的。

首先要知道**异或**的概念，两个数二进制同一位一样的异或结果是0，不一样则是1。

如果用暴力解题的话，l-r最大是九次方，会超时。所以我们换一种思路，先确定y在各个位上的数值，在处理一下从l到r上各个位的1的个数。

然后我们发现一段连续的数字他们各个位上的1，0出现具有**周期**性。可以利用这一点快速计算出各个位数上1的数量。

然后这里还有一个需要注意的点。最后我们求的期望值需要知道**直接除法不适用于求期望**。

这里需要用**费马小定理**的结论（适用于$mod$为质数）

​								$ a^{-1} =a ^{mod-2}$。

由于$mod-2$很大，运用**快速幂**求逆元。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<cstring>
#define int long long
using namespace std;
const int mod=1e9+7;
int t;
int ksm(int a,int b){//快速幂
    int res=1;
    while(b){
        if(b&1)res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
int s(int x,int b){
    int len=1LL<<(b+1);
    int zq=x/len;
    int res=zq*(len>>1);
    int tem=x%len;
    if((tem-(len>>1)+1)>=0){
        res+=(tem-(len>>1)+1);
    }
    return res;
}
int ss(int l,int r,int b){
    return s(r,b)-s(l-1,b);
}
void solve() {
    int l,r,y;
    cin>>l>>r>>y;
    int len=r-l+1;
    int inv=ksm(len,mod-2);
    int res=0;
    for(int i=0;i<=31;i++){
        int by=(y>>i)&1;
        int cn1=ss(l,r,i);
        int cn0=len-cn1;
        if(by==1){
            res=(res+cn0)%mod;
        }else{
            res=(res+cn1)%mod;
        }
    }
    res=res*inv%mod;
    cout<<res<<'\n';
}
signed main() {
    t =1;
	cin >> t;
	while (t--) {
		solve();
	}
}
```

---

# L-分块高手彻底怒了

![image-20250725220436799](C:\Users\Lee W\AppData\Roaming\Typora\typora-user-images\image-20250725220436799.png)

![image-20250725220946836](C:\Users\Lee W\AppData\Roaming\Typora\typora-user-images\image-20250725220946836.png)

理清函数内各个数的关系实现即可。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <cstring>
#define int long long
using namespace std;
const int MOD = 1e9+7;
int t;
int a[100010], b[100010], c[100010], f[100010], g[100010];
int qpow(int base, int exp) {
    int res = 1;
    base %= MOD;
    while (exp) {
        if (exp & 1) res = res * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return res;
}
int invv(int a, int b) {
    return a * qpow(b, MOD - 2) % MOD;
}
void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) cin >> c[i];
    int ans = 0;
    for (int k = 1; k <= n; k++) {
        int term = k * (k + 1) / 2 % MOD;
        ans = (ans + term * c[k] % MOD) % MOD;
    }
    for (int i = n; i >= 1; i--) {
        f[i] = (f[i + 1] + n / i) % MOD;
    }
    for (int i = n; i >= 1; i--) {
        int inv_b = invv(1, b[i]);
        g[i] = (g[i + 1] + inv_b * (n / i) % MOD * f[i] % MOD) % MOD;
    }
    for (int i = 1; i <= n; i++) {
        ans = (ans + g[i] * a[i] % MOD * (n / i) % MOD) % MOD;
    }
    cout << ans << '\n';
}
signed main() {
    t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

# E-咕咕嘎嘎!!!(easy)

利用背包，先初始化m为1的时候方案数是1，然后状态转移，最后累加。

```cpp
#include<bits/stdc++.h>
using namespace std;
int mod=1e9+7;
int dp[5050][5050];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        (dp[i][1]+=1)%=mod;
        for(int g=1;g<i;g++){
            for(int j=m;j>=2;j--){
                (dp[gcd(g,i)][j]+=dp[g][j-1])%=mod;   
            }
        }
    }
    int ans=0;
    for(int g=2;g<=n;g++)
        (ans+=dp[g][m])%=mod;
    cout<<ans;

    return 0;
}
```

---

# F 咕咕嘎嘎!!!(hard)

首先我们要知道一个东西——**莫比乌斯函数**$μ(n)$。

莫比乌斯函数是个特别的函数，它的值只取${\{-1,0,1}\}$，具体定义如下：

给定正整数 $n$，$μ(n)$ 定义如下：

| 条件                                    | $μ(n)$   | 例子                                                         |
| --------------------------------------- | -------- | ------------------------------------------------------------ |
| $n = 1$                                 | 1        | —                                                            |
| $n$含有平方因子（即某质因数出现 ≥2 次） | 0        | $n = 4 = 2^2, n = 18 = 3^2 \times 2$                         |
| $n$ 是 $k$ 个**不同质数**的乘积         | $(-1)^k$ | $n = 6 = 2 \times 3 \Rightarrow \mu = 1；$ $ n = 30 = 2 \times 3 \times 5 \Rightarrow \mu = -1$ |

性质：
$$
\sum_{d|n} \mu(d) = 
\begin{cases} 
1 & \text{if } n = 1 \\ 
0 & \text{if } n > 1 
\end{cases}
$$
$d|n$表示$d$是$n$的约数。

然后来到了重头戏——**莫比乌斯反演公式**

设：
$$
F(n)=\sum_{d|n}f(d)
$$
即$F$ 是 $f$的约数前缀和。

那么反过来可以通过 **莫比乌斯反演** 恢复 $f(n)$：
$$
f(n)=\sum_{d|n}\mu(d) \cdot F(\frac n d)
$$
也可以写成：
$$
f(n)=\sum_{d|n}\mu(\frac n d)\cdot F(d)
$$

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using ll = long long;
using namespace std;

const int N = 4e7 + 10;     // 阶乘、组合和莫比乌斯函数预处理的上限
const int mod = 1e9 + 7;    

vector<int> p;        // 存质数
bool flg[N];          // flg[i]=true 表示 i 不是质数
int mu[N];            // 莫比乌斯函数 μ(i)

// 莫比乌斯函数线性筛，复杂度 O(n)
void getmu(int n) {
    mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!flg[i]) {
            p.push_back(i);
            mu[i] = -1;  // i 是质数，μ(i) = -1
        }
        for (int pj : p) {
            if (i * pj > n) break;
            flg[i * pj] = true;
            if (i % pj == 0) {
                mu[i * pj] = 0;  // 出现平方因子
                break;
            }
            mu[i * pj] = -mu[i];
        }
    }
}

// 组合数预处理数组
int fact[N], inv[N];

// 快速幂，计算 a^b mod p
ll qpow(ll a, ll b, ll p) {
    a %= p;
    ll ans = 1 % p;
    while (b) {
        if (b & 1) ans = ans * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return ans;
}

// 初始化组合数阶乘和逆元
void init() {
    fact[0] = 1;
    inv[0] = 1;
    for (int i = 1; i < N; i++)
        fact[i] = (ll(i) * fact[i - 1]) % mod;
    inv[N - 1] = qpow(fact[N - 1], mod - 2, mod);  // 使用费马小定理求逆元
    for (int i = N - 2; i >= 1; i--) {
        inv[i] = inv[i + 1] * (i + 1ll) % mod;
    }
}

// 组合数 C(n, r) = n! / (r! * (n-r)!)
ll C(ll n, ll r) {
    if (r > n || r < 0) return 0;
    if (n == r || r == 0) return 1;
    return (ll(fact[n]) * inv[r] % mod * inv[n - r] % mod);
}

int main() {
    init();  // 初始化阶乘和逆元数组
    int n, m;
    cin >> n >> m;

    // 特判 m = 1，答案为 n-1（因为最大公因数只能为 2 ~ n）
    if (m == 1) {
        cout << n - 1;
        return 0;
    }

    getmu(n / m);  // 莫比乌斯函数只需要到 n / m（优化点）

    ll ans = 0;
    // 枚举所有可能的最大公因数 e，从 2 到 n/m
    for (int i = 2; i <= n / m; i++) {
        // g(e) = ∑ mu(i) * C(n / i, m)，这里 i 就是 d（μ的变量）
        // 注意 mu[i] 可能为负，结果要加 mod 保证非负
        ans = (ans - mu[i] * C(n / i, m) % mod + mod) % mod;
    }

    cout << ans;
    return 0;
}
```

- 关于为什么`getmu(n\m)`?

因为想让最大公因数为 $e$，则必须能选出 $m$ 个 $e$ 的倍数；

即 $\left\lfloor \frac{n}{e} \right\rfloor \ge m$，否则方案数是 0；

所以最大可能的 $e \le \left\lfloor \frac{n}{m} \right\rfloor$

> 真的尽力了

---

# J-猜数游戏hard

如果要猜的数是x，那么答案在x/k到x*k之中都算猜测成功。

我们利用分段估算要覆盖的区间数量

```cpp
a₁ = 1
aᵢ = k * k * aᵢ₋₁ + 1
```

然后求最少$i$次二分可以覆盖这些段落

```cpp
2^i ≥ st
```

最后i次即为结果

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<cstring>
#define int long long
using namespace std;
int t;
void solve() {
    int n,k;
    cin>>n>>k;
    int st=1;//段数
    __int128_t ans=1;//数据大！
    for(int i=1;i<=64;i++){//分段
        ans=ans*k*k+1;
        if(ans>n)break;
        st++;
    }
    if(k==1)st=n;
    for(int i=0;i<=64;i++){
        if((1ll<<i)>=st){
            cout<<i<<endl;
            break;
        }
    }
}
signed main() {
    t =1;
	//cin >> t;
	while (t--) {
		solve();
	}
}
```

---

# G-yume的灵机一动

先利用邻接表建树，再用bfs不断深入子树，从叶子节点开始向上走。

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<cstring>
#define int long long
using namespace std;
const int MAXN = 42005;
const int MAXK = 5505;
vector<int> tree[MAXN];
int a[MAXN];
int dp[MAXN][MAXK]; // 表示以 u 为根，选 i 个叶子后的最大权值和
int siz[MAXN];      // 表示以 u 为根的子树中叶子节点个数
bool isLeaf[MAXN];

void dfs(int u, int fa) {
    isLeaf[u] = true;  // 默认当成叶子，等下发现有儿子再改为 false
    dp[u][0] = 0;       // 什么都不选，收益为0

    for (int v : tree[u]) {
        if (v == fa) continue; // 忽略父节点，防止走回头路
        dfs(v, u);             // 递归处理子树
        isLeaf[u] = false;     // 有子节点，不是叶子
        // 背包合并：合并当前u的已有dp和子节点v的dp
        for (int i = siz[u]; i >= 0; i--) {
            for (int j = 0; j <= siz[v]; j++) {
                if (i + j <= MAXK) {
                    dp[u][i + j] = max(dp[u][i + j], dp[u][i] + dp[v][j]);
                }
            }
        }
        siz[u] += siz[v]; // 更新u子树中叶子节点个数
    }
    if (isLeaf[u]) {
        siz[u] = 1;          // 是叶子，能提供一个叶子
        dp[u][1] = a[u];     // 如果选这个叶子，贡献a[u]
    } else {
        // 如果我们选择了整棵子树的所有叶子，那么也要贡献a[u]
        dp[u][siz[u]] += a[u]; 
    }
}

int t;
void solve() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    dfs(1, 0);
    cout << dp[1][k] << '\n';
}

signed main() {
    t = 1;
    //cin >> t;
    while (t--) {
        solve();
    }
}
```
---
# H-被无尽数字1环绕

题目让我们找[0,*n*] 范围内二进制下 1的个数为 m的数有多少个

先预处理在i位中选j个1的组合数，再在二进制下从高到低依次遍历计算出集合的大小，最后二分查找结果。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long C[65][65];
void init() {//组合数 杨辉三角 i位中选j个1
    for (int i = 0; i <= 64; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j)
            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
    }
}
long long count(long long x, int m) {
    long long res = 0;
    int cnt = 0; // 已经放了多少个1
    for (int i = 60; i >= 0; --i) {
        if ((x >> i) & 1) { // 如果当前位是1，后面i位需要放m-cnt个1
            if (m - cnt >= 0)
                res += C[i][m - cnt]; // 当前位放0，其余i位选m-cnt个1
            cnt++; // 当前位选择1
        }
    }
    if (cnt == m) res++; // x本身也满足条件
    return res;
}
long long solve(long long n, int m, long long k) {
    if (count(n, m) < k) return -1;
    long long l = 0, r = n, ans = -1;
    while (l <= r) {
        long long mid = (l + r) >> 1;
        if (count(mid, m) >= k) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return ans;
}
int main() {
    init();
    int T;
    cin >> T;
    while (T--) {
        long long n, k;
        int m;
        cin >> n >> m >> k;
        cout << solve(n, m, k) << '\n';
    }
    return 0;
}
```

---
