# 牛客周赛103补题

## D-哥哥（好串）

开始看题目第一反应是二分次数，后来仔细看了题目。要求是字符串各不相同，然后思路开始偏了。

> 两个相同的变一次加一个好串
>
> 三个相同的变一次加两个好串
>
> 然后类推
>
> 四个相同的可以看成两个两个相同的子串
>
> 五个相同的可以看成一个长度二的一个长度三的子串
>
> 然后啊
>
> 然后就wa了

因为本题题目题意比较特别，至少包含三个好子串。

可以先遍历一遍得出没有改变的字符串，如果已经有了三个就可以直接输出0。

再后就是分类讨论

如果计数是2，说明字符串一定是xxxxyyyyzzzz这种类型的，只需要再变一个就至少三个好子串了。

但是有两个特例——1001,0110

特判这两个字符串，都需要变两次。

如果计数是1，说明字符串一定是xxxxxyyyyy这种的，只需要再变一个就至少三个了

但是依然有两个特例——1100,0011

还是特判

如果计数是0，那就是xxxxxxxxxx这样的，无论如何都需要变两个

按这个分类讨论即可

```cpp
#include <iostream>
using namespace std;
#define int long long
void solve() {
    int n;
    string s;
    cin >> n >> s;
    int res = 0;
    for (int i = 0; i + 1 < s.size(); ++i) {
        if (s[i] != s[i + 1]) res++;
    }
    if (res >= 3) {
        cout << 0 << endl;
        return;
    }
    if(res==2){
        if(s=="1001"||s=="0110"){
            cout<<2<<endl;
        }else{
            cout<<1<<endl;
        }
    }else if(res==1){
        if(s=="1100"||s=="0011"){
            cout<<2<<endl;
        }else{
            cout<<1<<endl;
        }
    }else if(res==0){
        cout<<2<<endl;
    }
}
signed main() {
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
}
```

---

## E-新婚（好路径）

看题目是树，有最近共同祖先，还有位运算，说实话，被唬住了。

看到树，先邻接表建树。

然后枚举每一个节点，依次遍历不断往上跳不断往下跳所能得到的值来记录结果、

但是要想能够遍历向上向下，需要知道它的父节点，子节点是什么。

子节点在我们建树的时候已经记录了，现在需要用bfs逐层记录每个子节点的父节点，用一个fa[]数组存储

同时由于最近共同祖先的限制，而且题目所给了我们数据大小，查询的最多是20位，所以我们只需要考虑每个点向上走二十步的情况。

现在我们知道了每个节点的子节点和父节点，就可以一个节点一个节点遍历他们向上或向下所能得到的值了

更新向下的
$$
d=(d<<1)+a[cur]
$$
由于向下是一个一个往右加，先位运算将现在的结果往左移一格再加上当前节点的权值。

更新向上的
$$
u=u+(1LL<<l)*a[cur]
$$
由于向上是一个一个往左加，所以直接是原本的值加上当前权值往左移已经跳了的步数。

然后ans数组记录是否存在。

最后输出查询的是否存在。

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
#define int long long
int n,q;
int a[10000010];
vector<int> g[10000010];
int fa[10000010],ans[10000010];
queue<int> qu;
void fu(){
    fa[1]=0;
    qu.push(1);
    while(!qu.empty()){
        int top=qu.front();
        qu.pop();
        for(int x:g[top]){
            if(x==fa[top])continue;
            fa[x]=top;
            qu.push(x);
        }
    }
}
void solve(){
    cin>>n>>q;
    string s;
    cin>>s;
    for(int i=1;i<=n;i++){
        a[i]=s[i-1]-'0';
    }
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    fu();
    for(int i=1;i<=n;i++){
        int d=0,u=0;
        int cur=i;
        for(int l=0;l<=20;l++){
            if(cur==0)break;
            d=(d<<1)+a[cur];
            u=u+(1LL<<l)*a[cur];
            ans[d]=1;
            ans[u]=1;
            cur=fa[cur];
        }
    }
    while(q--){
        int te;
        cin>>te;
        if(ans[te])cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
}
signed main(){
    int t=1;
    //cin>>t;
    while(t--){
        solve();
    }
}
```

