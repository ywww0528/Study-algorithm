# 河南萌新联赛第五场补题

## C-中位数+1

对顶堆模板题

```cpp
#include <bits/stdc++.h>
int main() 
{
    std::priority_queue<int> l; 
    std::priority_queue<int, std::vector<int>, std::greater<int>> r; 
    int n; 
    std::cin >> n;
    for (int i = 0; i < n; ++i) 
    {
        int num; 
        std::cin >> num;
        if (l.empty() || num <= l.top()) l.push(num);
        else r.push(num);

        if (l.size() > r.size() + 1) 
        {
            r.push(l.top());
            l.pop();
        } 
        else if (r.size() > l.size()) 
        {
            l.push(r.top());
            r.pop();
        }
        if (l.size() > r.size()) std::cout << l.top()<<" ";
        else std::cout << (l.top() + r.top()) / 2 <<" ";
    }
    return 0;
}
```

---

## H-简单题+

首先我们通过它的题意发现这是斐波那契数列求和

当n非常大时，逐步会超时。

需要利用矩阵求斐波那契数列和

**核心思路**

1. 已知公式：

$$
Sn=F0+F1+⋯+Fn=Fn+2−1S_n = F_0 + F_1 + \dots + F_n = F_{n+2} - 1
$$

2. 斐波那契数可以用矩阵表示：

$$
\begin{bmatrix} F_{n+1} \\ F_n \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^n \begin{bmatrix} 1 \\ 0 \end{bmatrix}
$$



3. 快速幂（矩阵）可以在 O(log n) 内求 $F_n$。



```cpp
#include <iostream>
using namespace std;
typedef long long ll;
const ll MOD = 998244353;
// 矩阵乘法
void matMul(ll a[2][2], ll b[2][2], ll mod) {
    ll res[2][2];
    res[0][0] = (a[0][0]*b[0][0] % mod + a[0][1]*b[1][0] % mod) % mod;
    res[0][1] = (a[0][0]*b[0][1] % mod + a[0][1]*b[1][1] % mod) % mod;
    res[1][0] = (a[1][0]*b[0][0] % mod + a[1][1]*b[1][0] % mod) % mod;
    res[1][1] = (a[1][0]*b[0][1] % mod + a[1][1]*b[1][1] % mod) % mod;
    a[0][0] = res[0][0];
    a[0][1] = res[0][1];
    a[1][0] = res[1][0];
    a[1][1] = res[1][1];
}
// 矩阵快速幂
void matPow(ll a[2][2], ll n, ll mod) {
    ll res[2][2] = {{1,0},{0,1}}; // 单位矩阵
    while (n) {
        if (n & 1) matMul(res, a, mod);
        matMul(a, a, mod);
        n >>= 1;
    }
    a[0][0] = res[0][0];
    a[0][1] = res[0][1];
    a[1][0] = res[1][0];
    a[1][1] = res[1][1];
}
// 求 F_n
ll fib(ll n, ll mod) {
    if (n == 0) return 0;
    ll mat[2][2] = {{1,1},{1,0}};
    matPow(mat, n-1, mod);
    return mat[0][0];
}
int main() {
    ll n;
    cin >> n;
    ll sum = (fib(n+2, MOD) - 1 + MOD) % MOD; // 前 n 项和
    cout << sum << endl;
    return 0;
}
```

---

## E-中位数+3

就是求k进制下n的阶乘的后置零个数

对 $k=\prod p_i^{e_i}$ 的每个质因子 $p$ 用 $Legendre$ 公式计算
$$
v_p(n!)=\sum_{t\ge1}\left\lfloor\frac{n}{p^t}\right\rfloor
$$
然后答案为 $\min_i\left\lfloor\frac{v_{p_i}(n!)}{e_i}\right\rfloor$。

```cpp
#include <bits/stdc++.h>
using ll = long long;
int main() {
    ll n; ll k;
    std::cin >> n >> k;
    std::vector<std::pair<ll,int>> fac;
    ll tk = k;
    for (ll p = 2; p * p <= tk; ++p) {
        if (tk % p == 0) {
            int e = 0;
            while (tk % p == 0) {
                tk /= p;
                ++e;
            }
            fac.emplace_back(p, e);
        }
    }
    if (tk > 1) fac.emplace_back(tk, 1);
    ll ans = LLONG_MAX;
    for (auto [p, e] : fac) {
        ll cnt = 0;
        ll pw = p;
        while (pw <= n) {
            cnt += (ll)(n / (ll)pw);
            pw *= p;
        }
        ans = std::min(ans, cnt / e);
    }
    std::cout << ans << '\n';
    return 0;
}
```

---

## I-Re:从零开始的近世代数复习（easy）

首先需要利用dfs来遍历得到该树各个节点的深度，权值和

通过利用倍增求这两个定理的最近共同祖先（LCA）来求出所需和

即根节点到x节点的权值和加上根节点到y节点的权值和在减去根节点到他们的最近共同祖先的权值和

```cpp
#include <bits/stdc++.h>
#define int long long
const int N = 1e5 + 10;
int n, q;
int a[N], sumv[N], dep[N], f[N][20];
std::vector<int> g[N];
void bfs(int x,int fa){
    dep[x]=dep[fa]+1;
    f[x][0]=fa;
    sumv[x]=sumv[fa]+a[x];
    for(int i=1;i<=19;i++){
        f[x][i]=f[f[x][i-1]][i-1];
    }
    for(auto v:g[x]){
        if(v==fa)continue;
        bfs(v,x);
    }
}
int lca(int u,int v){
    if(dep[u]<dep[v])std::swap(u,v);
    for(int i=19;i>=0;i--){
        if(dep[f[u][i]]>=dep[v])u=f[u][i];
    }
    if(u==v)return u;
    for(int i=19;i>=0;i--){
        if(f[u][i]!=f[v][i]){
            u=f[u][i];
            v=f[v][i];
        }
    }
    return f[u][0];
}
signed main(){
    int n,q;
    std::cin>>n;
    for(int i=1;i<=n;i++)std::cin>>a[i];
    for(int i=1;i<=n-1;i++){
        int u,v;
        std::cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    std::cin>>q;
    dep[0]=-1;
    bfs(1,0);
    while(q--){
        int k;
        std::cin>>k;
        int x,y;
        std::cin>>x>>y;
        int tem=lca(x,y);
        std::cout<<sumv[x]+sumv[y]-sumv[tem]<<std::endl;
    }
}
```

---

## L-防k题

防k题（假）防止咔咔被乱杀题（真）

根据题目所给求最少需要的咔咔数量

首先想到的是二分答案，二分需要的咔咔数量。

关键在于check函数怎么写

check函数里面需要进行模拟来验证x个咔咔是否能击败对方

很可惜比赛时因为题面复杂没看

```cpp
#include<iostream>
#include<climits>
int x1,y1,z,x2,y2;
bool check(int x){
    int cc=z;
    int cnt=x;
    int sh=y1;
    int kk=x1;
    int zz=x2;
    int dj=y2;
    while(cnt){
        for(int i=1;i<=3;i++){
            kk-=dj;
            if(kk<=0){
                if(cnt){
                    cnt--;
                }else{
                    break;
                }
                kk=x1;
            }
        }
        zz-=cnt*sh;
        sh+=cc;
        if(zz<=0){
            return true;
        }
    }
    return false;
}
int main(){
    std::cin>>x1>>y1>>z>>x2>>y2;
    int l=0,r=INT_MAX;
    int ans=0;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }else{
            l=mid+1;
        }
    }
    std::cout<<ans<<std::endl;
}
```

---

## J-Re:从零开始的近世代数复习（hard）

和前面那个不一样的就是k的范围

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
const int N = 100010;
int a[N], lg[N], d[N];//权值，倍增，深度
int fa[N][22];
long long sum[N];   // 从根到该点的路径和
int dfn[N], idx=0;  // dfs 序
std::vector<int> g[N];
void init(int n){
    for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
}
void dfs(int u,int f){
    dfn[u]=++idx;
    fa[u][0]=f;
    d[u]=d[f]+1;
    sum[u]+=a[u];
    for(int i=1;i<=lg[d[u]];i++){
        fa[u][i]=fa[fa[u][i-1]][i-1];
    }
    for(auto v:g[u]){
        if(v==f) continue;
        sum[v]=sum[u];
        dfs(v,u);
    }
}

int lca(int x,int y){
    if(d[x]<d[y]) std::swap(x,y);
    while(d[x]>d[y]){
        x=fa[x][lg[d[x]-d[y]]];
    }
    if(x==y) return x;
    for(int k=lg[d[x]];k>=0;k--){
        if(fa[x][k]!=fa[y][k]){
            x=fa[x][k];
            y=fa[y][k];
        }
    }
    return fa[x][0];
}

int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    int n;
    std::cin>>n;
    for(int i=1;i<=n;i++) std::cin>>a[i];
    for(int i=1;i<n;i++){
        int u,v;
        std::cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    init(n);
    dfs(1,0);

    int q;
    std::cin>>q;
    while(q--){
        int t;
        std::cin>>t;
        std::vector<std::pair<int,int>> v;
        for(int i=1;i<=t;i++){
            int x;
            std::cin>>x;
            v.push_back({dfn[x],x});
        }
        sort(v.begin(),v.end());
        long long ans=0;
        int pre=v[0].second;
        ans += sum[pre];
        for(int i=1;i<t;i++){
            int now=v[i].second;
            ans += sum[now] - sum[lca(now,pre)];
            pre=now;
        }
        std::cout<<ans<<"\n";
    }
    return 0;
}
```

