# 河南萌新联赛第四场补题

## B-0!!!!!

设$ F_p(n)$为满足$p^x$整除区间$[1,n]$中所有整数的因数的乘积的最大非负整数$x$.

对于$ F_p(n)$可以得到以下递推式：
$$
F_p(n)=\sum_{i=1}^n\sum_{d|k}\sum_{k=1}[p^k|d]
$$
枚举$[1,n]$改为先枚举约数

然后化简：
$$
F_p(n)=\sum_{k=1}\sum_{d=1,p^k|d}^{n}\lfloor{p^k|d}\rfloor
$$
d和n同除$p^k$：
$$
F_p(n)=\sum_{k=1}\sum_{d=1}^{\lfloor{\frac{n}{p^k}}\rfloor}\lfloor\frac{\lfloor\frac{n}{p^k}\rfloor}{d}\rfloor
$$

```cpp
#include<iostream>
#define int long long
int solve(int x,int l){
    int ans=0;
    for(int i=x;i<=l;i*=x){
        int n=l/i;
        for(int j=1;j<=n;j=n/(n/j)+1){
            int k=n/(n/j);
            ans+=(k-j+1)*(n/j);
        }
    }
    return ans;
}
signed main(){
    int l,r;
    std::cin>>l>>r;
    int a=solve(2,r)-solve(2,l-1);
    int b=solve(5,r)-solve(5,l-1);
    std::cout<<std::min(a,b)<<endl;
}
```

---

## D-箭头谜题Ⅰ

> 首先一看先试试最熟练的dfs
>
> 然后果不其然tle
>
> 同时因为用了三维数组调了好久的mle

还得是bfs找最短路

这里首先用了tuple来存储三个元素的关系对，方便存储

然后是常规的bfs，有个小细节是当当前的路不需要花费时，是放到最前面。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include<queue>
#define int long long
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int n, m, k;
std::vector<std::string> a;
std::deque<std::tuple<int,int,int>> qu;
std::string s0="UDLR";
void solve() {
    std::cin >> n >> m >> k;
    a.assign(n,"");
    for (int i = 0; i < n; ++i) {
        std::cin>>a[i];
    }
    std::vector<std::vector<int>> vis(n,std::vector<int>(m,-1));
    qu.push_front({0,0,0});
    while(!qu.empty()){
        auto[x,y,c]=qu.front();
        qu.pop_front();
        if(vis[x][y]!=-1)continue;
        vis[x][y]=c;
        for(int i=0;i<4;++i){
            int xx=x+dx[i];
            int yy=y+dy[i];
            if(xx<0||xx>=n||yy<0||yy>=m||vis[xx][yy]!=-1)continue;
            if(a[x][y]==s0[i]){
                qu.push_front({xx,yy,c});
            }else{
                qu.push_back({xx,yy,c+1});
            }
        }
    }
    std::cout << (vis[n-1][m-1]<=k ? "YES" : "NO") << '\n';
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

---

## L-故障机器人的完美遗物

这里找到~~偷到~~到两个板子

这个是用来判断某个数是不是质数的并存进表里面

```cpp
vector<int> primes;
vector<bool> is_prime;//判断质数

void prime_table(int N) {
    is_prime.assign(N + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= N; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int p : primes) {
            if (i * p > N) break;
            is_prime[i * p] = false;
            if (i % p == 0) break;
        }
    }
}
```

这个是判断$t^2$的约数个数的

```cpp
// 预先调用 prime_table(N) 得到 primes 表
// 快速计算 t^2 的约数个数
int count_divisors_of_square(int t) {
    int res = 1;
    for (int p : primes) {
        if (1LL * p * p > t) break;
        int cnt = 0;
        while (t % p == 0) {
            cnt++;
            t /= p;
        }
        res *= (2 * cnt + 1);
    }
    if (t > 1) res *= 3; // 还剩一个大质因子
    return res;
}
```

最后就只需要先预处理存进去所有因数为质数的数，最后如果有就累加

用unordered_set插入省时间

```cpp
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    prime_table(1e6);
    for (int t = 1; 1LL * t * t <= 1e12; ++t) {
        int d = count_divisors_of_square(t);
        if (d < is_prime.size() && is_prime[d]) {
            set.insert(1LL * t * t);
        }
    }

    int n;
    cin >> n;
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        int x;
        cin >> x;
        if (set.count(x)) {
            ans += x;
        }
    }

    cout << ans << '\n';
    return 0;
}
```

---

