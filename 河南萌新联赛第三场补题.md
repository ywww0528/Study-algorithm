# 第三场补题

## B-上海保卫战

开始以为是模拟，然后交了一发发现tle，后来发现奇数和偶数的差别ac。

```cpp
#include<iostream>
#define int long long
using namespace std;
int n,cnt=1;
int prime(int x){
    for(int i=2;i*i<=x;i++){
        if(x%i==0) return i;
    }
    return x;
}
signed main(){
    cin>>n;
    int m;
    m=prime(n);
    if(n&1){
        cnt+=(n-m)/2+1;
    }else{
        cnt+=n/2;
    }
    cout<<cnt<<endl;
}
```

---

## K-魔法音符

接雨水，左右最大值走一遍然后取最小值，再一一减去原先的高度累加。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int m,n,i,j,k;
int a[200020],mx1[200020],mx2[200020];
void solve()
{
    int ma=0,ans=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        mx1[i]=max(mx1[i-1],a[i]); 
    }
    for(int i=n;i>=1;i--)mx2[i]=max(mx2[i+1],a[i]);
    for(int i=1;i<=n;i++)
    {
        ma=min(mx1[i],mx2[i]);
        ans+=ma-a[i];
    }
    cout<<ans<<"\n";
    return;
}
signed main()
{
    int T=1;
    while(T--)solve();
    return 0;
}
```

---

## G-方案数

高中数学，组合数和快速幂

```cpp
#include<iostream>
#define int long long
using namespace std;
int c[1010][1010];
const int mod=1e9+7;
int zh(int n,int k){
    c[0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=i;j++){
            if(!j)c[i][j]=c[i-1][j];
            else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
        }
    }
    return c[n][k];
}
int ksm(int m,int k){
    int ans=1;
    while(k){
        if(k&1){
            ans=ans*m%mod;
        }
        m=m*m%mod;
        k>>=1;
    }
    return ans%mod;
}
signed main(){
    int n,k,m;
    cin>>n>>k>>m;
    int an1=zh(n,k);
    int an2=ksm(m,k);
    int ans=(an1*an2)%mod;
    cout<<ans<<endl;
}
```

---

## H-连续合规子串

双指针

```cpp
#include <iostream>
#define ll long long int
using namespace std;
int main()
{
    ll n;
    cin >> n;
    string s;
    cin >> s;
    ll l = 0;
    ll ans = 1;
    for (ll r = 1; r < n; r++)
    {
        if (s[r] == s[r - 1])
        {
            l = r;
        }
        else if (r >= 2 && s[r] == s[r - 2])
        {
            l = r - 1;
            if (s[r] == s[r - 1])
            {
                l = r;
            }
        }
        ans = max(ans, r - l + 1);
    }
    cout << ans << endl;
    return 0;
}
```

---

## E-星际争霸

开始直接做交了一发tle了，后来直接二分搜索果然比一个一个比对快。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100010],aa[100010];
struct x{
    int d;
    int g;
}b[100010];
bool cmp(x a,x b){
    return a.d<b.d;
}
int ef(int x,int l,int r){
    while(l<r){
        int mid=(l+r+1)>>1;
        if(b[mid].d<=x)l=mid;
        else r=mid-1;
    }
    return l;
}
int main(){
    int s,n;
    cin>>s>>n;
    for(int i=1;i<=s;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        cin>>b[i].d>>b[i].g;
    }
    sort(b+1,b+1+n,cmp);
    aa[0]=0;
    for(int i=1;i<=s;i++){
        aa[i]=aa[i-1]+b[i].g;
    }
    for(int i=1;i<=s;i++){
        int id=ef(a[i],0,n);
        cout<<aa[id]<<" ";
    }
}
```

---

## A-检讨

二分猜测平均值，前缀和转化问题为是否存在数组长度>=L的和大于0使得这个平均值存在。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int a[200020];
int n,le;
bool check(double mid){
    vector<double> aa(n+1,0);
    for(int i=1;i<=n;i++){
        aa[i]=aa[i-1]+a[i]-mid;
    }
    double res=0;
    for(int i=le;i<=n;i++){
        res=min(res,aa[i-le]);
        if(aa[i]-res>=0)return true;
    }
    return false;
}
void solve(){
    cin>>n>>le;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    double l=-1e4,r=1e4;
    while(r-l>1e-6){
        double mid=(l+r)/2;
        if(check(mid))l=mid;
        else r=mid;
    }
    printf("%.5f\n",l);
}
int main(){
    int t;
    cin>>t;
    while(t--){
        solve();
    }
    return 0;
}
```

---

## M-神魔大战

记录正贡献和反贡献的差值数组，单独记录总贡献。转化为在差值为0的情况下总贡献的最大值。背包问题。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int a[10020],b[100020];
int f[3][20010];
int main(){
    int n,ma=0,mi=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];//a[i]转为了记录总贡献的数组
        ma+=a[i];
    }
    for(int i=1;i<=n;i++){
        cin>>b[i];
        mi-=b[i];
        b[i]=a[i]-b[i];//b[i]转化为了记录贡献差值的数组
    }
    memset(f,-0x3f,sizeof(f));
    f[0][-mi]=0;
    for(int i=1;i<=n;i++){
        for(int j=mi;j<=ma;j++){
            if(j-mi-b[i]>=0){
                f[i&1][j-mi]=max(f[!(i&1)][j-mi],f[!(i&1)][j-b[i]-mi]+a[i]);
            }else{
                f[i&1][j-mi]=f[!(i&1)][j-mi];
            }
        }
    }
    cout<<max(0,f[n&1][-mi]);
    return 0;
}
```

